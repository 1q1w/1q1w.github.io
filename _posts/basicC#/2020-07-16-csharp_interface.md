---
layout: single
title: "[C# Basic] 인터페이스 사용법"
categories:
  - C# Basic
toc: true
toc_sticky: true
toc_label: "On this Page"
date: 2020-07-16
---



C#의 기초부터 차근차근 다시 한 번 짚어보자.  

이번에는 인터페이스를 작성하고 활용하는 방법에 대해 알아보자

-----

##### * 인터페이스 선언

```c#
interface BonoBono{
    string Name {get; set;}
    
    void Talk();
    void Walk();
}
```

- 인터페이스는 interface 키워드를 사용해 선언한다
- 클래스와 비슷해 보이지만 인터페이스는 메소드, 이벤트, 인덱서, 프로퍼티만 가질 수 있다.
- 인터페이스는 메소드, 이벤트, 인덱서, 프로퍼티의 구현부가 없다.

- 접근제한 한정자를 사용할 수 없고 클래스는 접근한정자가 없으면 private이지만, 인터페이스는 모두 public으로 선언된다.



##### * 인터페이스 사용

```c#
class Bono : BonoBono{
    public string Name {get; set;}
    
    public void Talk(){
        Console.WriteLine("Talk");
    }
    public void Walk(){
        Console.WriteLine("Walk");
    }
}
```

- 인터페이스를 상속받는 클래스는 인터페이스의 모든 멤버를 구현해야 한다
- 이 때 구현된 멤버들은 모두 public이어야 한다.

```c#
BonoBono bono = new Bono();  // 인터페이스를 이용한 참조 만들기
bono.Talk();
```

- 인터페이스는 인스턴스를 못만들지만, 참조는 만들 수 있다.
- 파생 클래스는 기반 클래스와 같은 형식으로 간주한다는 클래스의 규칙에 따라, 인터페이스를 상속받는 파생클래스는 인터페이스와 같은 형식으로 간주된다.  즉 위 예제에서 BonoBono 인터페이스와 Bono 클래스는 같은 형식으로 간주된다.
- 인터페이스는 자신을 상속한 클래스가 반드시 어떤 멤버들을 구현하도록 강제한다.  즉 프로그래밍 시 하나의 약속을 정해놓는것이라 볼 수 있다.



##### * 인터페이스를 상속하는 인터페이스

```c#
interface Animal{
    // 내용
}

interface BonoBono : Animal{
    // 추가할 내용
}
```

- 인터페이스 상속은 인터페이스를 수정할 수 없는 경우 사용해야 한다.
- 상속하려는 인터페이스가 소스코드가 아닌 어셈블리로만 제공되는 경우. (.NET Framework SDK에서 제공하는 인터페이스 등)   어셈블리 안에 있으면 직접 수정할 수 없다.  따라서 인터페이스에 기능을 추가하고싶다면 상속받아서 기능을 추가해야 한다.
- 상속하려는 인터페이스를 이미 많은 클래스가 사용하는 경우.  이 경우 인터페이스를 수정하고 되면 클래스들도 모두 수정해야 한다.  (클래스는 인터페이스를 모두 구현해야 하므로)  기존 코드에 영향이 없게 하려면 인터페이스를 상속받는것이 나을 수 있다.



##### * 인터페이스 다중상속

- 클래스는 여러 클래스를 한 번에 상속할 수 없다.  그 이유는 상속받는 클래스들의 메소드 이름이 동일한 경우 어떤것을 물려받을지 모호하기 때문이다.
- 인터페이스를 상속받는 경우 여러 인터페이스를 상속받는 것이 가능하다.  그 이유는 인터페이스는 구현이 아닌 실체가 없는 약속에 불과하기 때문이다.  이름이 중복되더라도 단지 그것을 클래스에서 구현만 하면 된다.
- **상속은 구현을 위한 장치가 아닌 다형성을 위한 장치**로써 다양한 버전의 모습을 가질 수 있도록 한다.



##### * 추상클래스

```c#
abstract class Animal{
    public abstract void Talk();  // 추상메소드
    
    public void Walk(){
        Console.WriteLine("Walk");
    }
}

class BonoBono : Animal{
    public override void Talk(){
        Console.WriteLine("Talk");
    }
    
    public void Walk(){
        Console.WriteLine("Walk");
    }
    
}
```

- 추상클래스는 인터페이스와 달리 구현을 가질 수 있다.  하지만 클래스와 달리 인스턴스는 가질 수 없다.
- 추상클래스는 abstract 키워드로 선언한다.
- 추상클래스는 추상메소드를 가질 수 있다.  동일하게 abstract 키워드를 사용한다.
- 추상클래스는 상속받은 클래스는 추상메소드를 반드시 override 해야한다.
- 추상클래스는 클래스와 같이 접근한정자가 없으면 private이다.  하지만 추상메소드는 파생클래스에서 반드시 구현해야하므로 public, protected, internal, protected internal 중 하나로 수식하지 않으면 C# 컴파일러가 수정하라고 말해줄 것이다.

- 추상클래스가 추상클래스를 상속받은 경우 추상메소드는 구현하지 않아도 된다.  추상메소드는 인스턴스를 생성할 클래스에서 구현하면 된다





인터페이스와 추상클래스는 그것을 사용하는 프로그래머가 어떠한 구현을 만들도록 강제하는 역할을 한다.